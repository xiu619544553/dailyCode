# <center> `RunLoop` è¯¦è§£

### ç›®å½•
- ä¸€ã€`RunLoop` çš„æ¦‚å¿µ
    - 1ã€äº‹ä»¶å¾ªç¯ï¼ˆEvent Loopï¼‰æ¨¡å‹
    - 2ã€æºç ä¸‹è½½åœ°å€
    - 3ã€RunLoop çš„ä½œç”¨
- äºŒã€`RunLoop` çš„æ•°æ®ç»“æ„
    - 1ã€`CFRunLoopRef`
    - 2ã€`CFRunLoopModeRef`
    - 3ã€`CFRunLoopSourceRef`
    - 4ã€`CFRunLoopTimerRef`
    - 5ã€`CFRunLoopObserverRef`
- ä¸‰ã€`RunLoop` çš„äº‹ä»¶å¾ªç¯æœºåˆ¶
    - 1ã€`CFRunLoopRunSpecific` å‡½æ•°ï¼ŒRunLoop çš„å…¥å£
    - 2ã€`__CFRunLoopRun` å‡½æ•°å®ç°ï¼šäº‹ä»¶å¾ªç¯çš„å®ç°æœºåˆ¶
    - 3ã€`__CFRunLoopServiceMachPort` å‡½æ•°å®ç°ï¼šRunLoop ä¼‘çœ çš„å®ç°åŸç†
- å››ã€`RunLoop` çš„åº”ç”¨
    - 1ã€å¤„ç† `NSTimer` åœ¨ `UIScrollView` æ»‘åŠ¨æ—¶å¤±æ•ˆçš„é—®é¢˜
    - 2ã€åˆ©ç”¨ `RunLoop` ç›‘æ§åº”ç”¨å¡é¡¿

- äº”ã€`RunLoop` ç›¸å…³çš„é—®é¢˜
    - 1ã€`NSTimer` å’Œ `CADisplayLink` è®¡æ—¶ä¸å‡†ç¡®ï¼ŒåŠå…¶è§£å†³åŠæ³•
    
    
### å‰è¨€

RunLoop æ˜¯ iOS å’Œ OSX å¼€å‘ä¸­éå¸¸åŸºç¡€çš„ä¸€ä¸ªæ¦‚å¿µï¼Œè¿™ç¯‡æ–‡ç« å°†ä» CFRunLoop çš„æºç å…¥æ‰‹ï¼Œä»‹ç» RunLoop çš„æ¦‚å¿µä»¥åŠåº•å±‚å®ç°åŸç†ã€‚ä¹‹åä¼šä»‹ç»ä¸€ä¸‹åœ¨ iOS ä¸­ï¼Œè‹¹æœæ˜¯å¦‚ä½•åˆ©ç”¨ RunLoop å®ç°è‡ªåŠ¨é‡Šæ”¾æ± ã€å»¶è¿Ÿå›è°ƒã€è§¦æ‘¸äº‹ä»¶ã€å±å¹•åˆ·æ–°ç­‰åŠŸèƒ½çš„ã€‚


### ä¸€ã€`RunLoop` çš„æ¦‚å¿µ

#### 1ã€äº‹ä»¶å¾ªç¯ï¼ˆEvent Loopï¼‰æ¨¡å‹
ä¸€èˆ¬æ¥è®²ï¼Œä¸€ä¸ªçº¿ç¨‹ä¸€æ¬¡åªèƒ½æ‰§è¡Œä¸€ä¸ªä»»åŠ¡ï¼Œæ‰§è¡Œå®Œæˆåçº¿ç¨‹å°±ä¼šé€€å‡ºã€‚å¦‚æœæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæœºåˆ¶ï¼Œè®©çº¿ç¨‹èƒ½éšæ—¶å¤„ç†äº‹ä»¶ä½†å¹¶ä¸é€€å‡ºï¼Œé€šå¸¸çš„ä»£ç é€»è¾‘æ˜¯è¿™æ ·çš„ï¼š

```
function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
```

è¿™ç§æ¨¡å‹é€šå¸¸è¢«ç§°ä½œ `Event Loop`ã€‚ `Event Loop` åœ¨å¾ˆå¤šç³»ç»Ÿå’Œæ¡†æ¶é‡Œéƒ½æœ‰å®ç°ï¼Œæ¯”å¦‚ `Node.js` çš„äº‹ä»¶å¤„ç†ï¼Œæ¯”å¦‚ `Windows` ç¨‹åºçš„æ¶ˆæ¯å¾ªç¯ï¼Œå†æ¯”å¦‚ `OSX/iOS` é‡Œçš„ `RunLoop`ã€‚å®ç°è¿™ç§æ¨¡å‹çš„å…³é”®ç‚¹åœ¨äºï¼šå¦‚ä½•ç®¡ç†äº‹ä»¶/æ¶ˆæ¯ï¼Œå¦‚ä½•è®©çº¿ç¨‹åœ¨æ²¡æœ‰å¤„ç†æ¶ˆæ¯æ—¶ä¼‘çœ ä»¥é¿å…èµ„æºå ç”¨ã€åœ¨æœ‰æ¶ˆæ¯åˆ°æ¥æ—¶ç«‹åˆ»è¢«å”¤é†’ã€‚

æ‰€ä»¥ï¼Œ`RunLoop` å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡ç®¡ç†äº†å…¶éœ€è¦å¤„ç†çš„äº‹ä»¶å’Œæ¶ˆæ¯ï¼Œå¹¶æä¾›äº†ä¸€ä¸ªå…¥å£å‡½æ•°æ¥æ‰§è¡Œä¸Šé¢ `Event Loop` çš„é€»è¾‘ã€‚çº¿ç¨‹æ‰§è¡Œäº†è¿™ä¸ªå‡½æ•°åï¼Œå°±ä¼šä¸€ç›´å¤„äºè¿™ä¸ªå‡½æ•°å†…éƒ¨ â€œæ¥å—æ¶ˆæ¯->ç­‰å¾…->å¤„ç†â€ çš„å¾ªç¯ä¸­ï¼Œç›´åˆ°è¿™ä¸ªå¾ªç¯ç»“æŸï¼ˆæ¯”å¦‚ä¼ å…¥ `quit` çš„æ¶ˆæ¯ï¼‰ï¼Œå‡½æ•°è¿”å›ã€‚

`OSX/iOS` ç³»ç»Ÿä¸­ï¼Œæä¾›äº†ä¸¤ä¸ªè¿™æ ·çš„å¯¹è±¡ï¼š`NSRunLoop` å’Œ `CFRunLoopRef`ã€‚
* `CFRunLoopRef` æ˜¯åœ¨ `CoreFoundation` æ¡†æ¶å†…çš„ï¼Œå®ƒæä¾›äº†çº¯ `C` å‡½æ•°çš„ APIï¼Œæ‰€æœ‰è¿™äº› API éƒ½æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚
* `NSRunLoop` æ˜¯åŸºäº `CFRunLoopRef` çš„å°è£…ï¼Œæä¾›äº†é¢å‘å¯¹è±¡çš„ APIï¼Œä½†æ˜¯è¿™äº› API ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

#### 2ã€æºç ä¸‹è½½åœ°å€
* `CFRunLoopRef` çš„ä»£ç æ˜¯å¼€æºçš„ï¼Œæˆ‘ä»¬å¯ä»¥ä¸‹è½½åˆ°æ•´ä¸ª `CoreFoundation` çš„æºç æ¥æŸ¥çœ‹ï¼š[ä¼ é€é—¨](http://opensource.apple.com/tarballs/CF/)
* Swift å¼€æºåï¼Œè‹¹æœåˆç»´æŠ¤äº†ä¸€ä¸ªè·¨å¹³å°çš„ `CoreFoundation` ç‰ˆæœ¬ï¼š[ä¼ é€é—¨](https://github.com/apple/swift-corelibs-foundation/)

#### 3ã€RunLoop çš„ä½œç”¨
* ä¿è¯ç¨‹åºçš„æŒç»­è¿è¡Œ
* å¤„ç† APP ä¸­çš„å„ç§äº‹ä»¶ï¼ˆè§¦æ‘¸ã€å®šæ—¶å™¨ã€performSelectorï¼‰
* èŠ‚çœ CPU èµ„æºã€æé«˜ç¨‹åºçš„æ€§èƒ½ï¼šæœ‰äº‹å°±åšï¼Œæ²¡äº‹å°±ç¡çœ 


### äºŒã€`RunLoop` çš„æ•°æ®ç»“æ„

åœ¨ CoreFoundation é‡Œé¢å…³äº RunLoop æœ‰5ä¸ªç±»:

|  ç±»å   | ä»‹ç»  |
|  ----  | ----  |
| CFRunLoopRef | RunLoop å¯¹è±¡ | 
| CFRunLoopModeRef | RunLoop è¿è¡Œæ¨¡å¼ |
| CFRunLoopSourceRef | Input Source|
| CFRunLoopTimerRef | Timer Source|
| CFRunLoopObserverRef | ç›‘å¬ RunLoop çŠ¶æ€æ”¹å˜ |

å…¶ä¸­ `CFRunLoopModeRef` ç±»å¹¶æ²¡æœ‰å¯¹å¤–æš´éœ²ï¼Œåªæ˜¯é€šè¿‡ `CFRunLoopRef` çš„æ¥å£è¿›è¡Œäº†å°è£…ã€‚ä»–ä»¬çš„å…³ç³»å¦‚ä¸‹:

![RunLoopæ•°æ®ç»“æ„å…³ç³»å›¾](https://github.com/xiu619544553/dailyCode/blob/master/icons/runloopç»“æ„ä½“.png)

#### 1ã€`CFRunLoopRef`

RunLoopå¯¹è±¡çš„åº•å±‚å°±æ˜¯ä¸€ä¸ª `CFRunLoopRef` ç»“æ„ä½“ï¼Œå®ƒé‡Œé¢å­˜å‚¨ç€ï¼š
* `_pthread`ï¼šRunLoopä¸çº¿ç¨‹æ˜¯ä¸€ä¸€å¯¹åº”å…³ç³»
* `_commonModes`ï¼šå­˜å‚¨ç€ NSString å¯¹è±¡çš„é›†åˆï¼ˆMode çš„åç§°ï¼‰
* `_commonModeItems`ï¼šå­˜å‚¨ç€è¢«æ ‡è®°ä¸ºé€šç”¨æ¨¡å¼çš„Source0/Source1/Timer/Observer
* `_currentMode`ï¼šRunLoopå½“å‰çš„è¿è¡Œæ¨¡å¼
* `_modes`ï¼šå­˜å‚¨ç€RunLoopæ‰€æœ‰çš„ modeï¼ˆ`CFRunLoopModeRef` ç±»å‹ï¼‰


```
// CFRunLoopRef æ˜¯ç»“æ„ä½“æŒ‡é’ˆ
typedef struct __CFRunLoop * CFRunLoopRef;

struct __CFRunLoop {
    pthread_mutex_t _lock;		    // è®¿é—®æ¨¡å¼é›†åˆçš„é”
    __CFPort _wakeUpPort;			// used for CFRunLoopWakeUp
    Boolean _unused;
    volatile _per_run_data *_perRunData; // reset for runs of the run loop  é‡ç½® runloop çš„è¿è¡Œ
    pthread_t _pthread;               // RunLoopä¸çº¿ç¨‹æ˜¯ä¸€ä¸€å¯¹åº”å…³ç³»
    uint32_t _winthread;
    CFMutableSetRef _commonModes;     // å­˜å‚¨ç€ NSString å¯¹è±¡çš„é›†åˆï¼ˆMode çš„åç§°ï¼‰
    CFMutableSetRef _commonModeItems; // å­˜å‚¨ç€è¢«æ ‡è®°ä¸ºé€šç”¨æ¨¡å¼çš„ Source0/Source1/Timer/Observer
    CFRunLoopModeRef _currentMode;    // runloopå½“å‰çš„è¿è¡Œæ¨¡å¼
    CFMutableSetRef _modes;           // å­˜å‚¨ç€ runloop æ‰€æœ‰çš„ Modeï¼ˆCFRunLoopModeRefï¼‰
...çœç•¥...
};
```

#### 2ã€`CFRunLoopModeRef`

* CFRunLoopModeRefä»£è¡¨RunLoopçš„è¿è¡Œæ¨¡å¼ï¼›
* ä¸€ä¸ªRunLoopåŒ…å«è‹¥å¹²ä¸ª Modeï¼Œæ¯ä¸ª Mode åˆåŒ…å«è‹¥å¹²ä¸ªSource0/Source1/Timer/Observerï¼›
* RunLoopå¯åŠ¨æ—¶åªèƒ½é€‰æ‹©å…¶ä¸­ä¸€ä¸ª Modeï¼Œä½œä¸º currentModeï¼›
* å¦‚æœéœ€è¦åˆ‡æ¢ Modeï¼Œåªèƒ½é€€å‡ºå½“å‰ Loopï¼Œå†é‡æ–°é€‰æ‹©ä¸€ä¸ª Mode è¿›å…¥ï¼Œåˆ‡æ¢æ¨¡å¼ä¸ä¼šå¯¼è‡´ç¨‹åºé€€å‡ºï¼›
* ä¸åŒ Mode ä¸­çš„ Source0/Source1/Timer/Observerèƒ½åˆ†éš”å¼€æ¥ï¼Œäº’ä¸å½±å“ï¼›
* å¦‚æœ Mode é‡Œæ²¡æœ‰ä»»ä½• Source0/Source1/Timer/Observerï¼ŒRunLoopä¼šç«‹é©¬é€€å‡º

`CFRunLoopRef`éš”ç¦»ä¸åŒModeçš„ä¼˜ç‚¹ï¼š
 å¦‚æœåªèƒ½åœ¨ä¸€ç§æ¨¡å¼ä¸‹è¿è¡Œï¼Œå¯¹æ€§èƒ½ä»€ä¹ˆçš„éƒ½æœ‰å¾ˆå¤§å¥½å¤„ï¼Œæ¯”å¦‚æˆ‘åœ¨æ»‘åŠ¨æ¨¡å¼ä¸‹ï¼Œä¸è€ƒè™‘ä¸æ»‘åŠ¨çš„æ¨¡å¼ï¼Œæ‰€ä»¥å°±ä¸ä¼šå¡é¡¿,é¡ºç•…å¾ˆå¤šã€‚è¿˜æœ‰æ³¨æ„çš„å°±æ˜¯ï¼Œå®ƒåˆ‡æ¢modeæ˜¯åœ¨å¾ªç¯é‡Œé¢åˆ‡æ¢çš„ï¼Œæ‰€ä»¥ä¸ä¼šå¯¼è‡´ç¨‹åºé€€å‡ºã€‚

å¸¸è§çš„ Modeæœ‰2ç§ï¼Œå…¶ä»–æƒ…å†µå¾ˆå°‘è§ï¼Œæ‰€ä»¥æŒæ¡è¿™ä¸¤ä¸ªä¸€èˆ¬éƒ½æ˜¯æ²¡é—®é¢˜äº†
* `KCFRunLoopDefaultMode` (`NSDefaultRunLoopMode`): Appçš„é»˜è®¤Modeï¼Œé€šå¸¸æ˜¯ä¸»çº¿ç¨‹æ˜¯åœ¨è¿™ä¸ªModeä¸‹è¿è¡Œã€‚
* `UITrackingRunLoopMode` : ç•Œé¢è·Ÿè¸ª Modeï¼Œç”¨äºè¿½è¸ª `ScrollView` çš„è§¦æ‘¸æ»‘åŠ¨ï¼Œä¿è¯ç•Œé¢æ»‘åŠ¨æ—¶ä¸å—å…¶ä»–Modeå½±å“ã€‚


|  ModeName   | æè¿°  |
|  ----  | ----  |
| NSDefaultRunLoopModeã€KCFRunLoopDefaultMode  | é»˜è®¤æ¨¡å¼ |
| UITrackingRunLoopMode  | ç•Œé¢è¿½è¸ªæ¨¡å¼ï¼Œç”¨äº ScrollView è¿½è¸ªè§¦æ‘¸æ»‘åŠ¨ï¼Œä¿è¯ç•Œé¢æ»‘åŠ¨æ—¶ä¸å—å…¶ä»– Mode å½±å“ï¼› |
| NSRunLoopCommonModesã€KCFRunLoopCommonModes  | è¯¥æ¨¡å¼ä¸æ˜¯å®é™…å­˜åœ¨çš„ä¸€ç§æ¨¡å¼ï¼Œå®ƒåªæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æ ‡è®°ï¼Œæ˜¯åŒæ­¥ `Source0`/`Source1`/`Timer`/`Observer` åˆ°å¤šä¸ª Mode ä¸­çš„æŠ€æœ¯æ–¹æ¡ˆã€‚è¢«æ ‡è®°ä¸ºé€šç”¨æ¨¡å¼çš„ `Source0`/`Source1`/`Timer`/`Observer` éƒ½ä¼šå­˜æ”¾åˆ° `_commonModeItems` é›†åˆä¸­ï¼Œä¼šåŒæ­¥è¿™äº› `Source0`/`Source1`/`Timer`/`Observer` åˆ°å¤šä¸ª Mode ä¸­ï¼ˆå³ `CFRunLoopRef` çš„æˆå‘˜å˜é‡ `_modes`ï¼‰ã€‚ |

æ•°æ®ç»“æ„ï¼š
```
// CFRunLoopModeRef æ˜¯ç»“æ„ä½“æŒ‡é’ˆ
typedef struct __CFRunLoopMode *CFRunLoopModeRef;

struct __CFRunLoopMode {
    pthread_mutex_t _lock;	/* must have the run loop locked before locking 
    CFStringRef _name;              // mode ç±»å‹ï¼Œæ¯”å¦‚ï¼šKCFRunLoopDefaultMode
    CFMutableSetRef _sources0;      // CFRunLoopSourceRef è¾“å…¥æº0 é›†åˆ
    CFMutableSetRef _sources1;      // CFRunLoopSourceRef è¾“å…¥æº1 é›†åˆ
    CFMutableArrayRef _observers;   // CFRunLoopObserverRef ç›‘å¬äº‹ä»¶
    CFMutableArrayRef _timers;      // CFRunLoopTimerRef è®¡æ—¶å™¨æº é›†åˆ
    ...çœç•¥...
};
```

#### 3ã€`CFRunLoopSourceRef`

* åœ¨ RunLoop ä¸­æœ‰ä¸¤ä¸ªå¾ˆé‡è¦çš„æ¦‚å¿µï¼Œä¸€ä¸ªæ˜¯ä¸Šé¢æåˆ°çš„`æ¨¡å¼`ï¼Œè¿˜æœ‰ä¸€ä¸ªå°±æ˜¯`äº‹ä»¶æº`ã€‚äº‹ä»¶æºåˆ†ä¸º`è¾“å…¥æº`ï¼ˆInput Sourcesï¼‰å’Œ`å®šæ—¶å™¨æº`ï¼ˆTimer Sourcesï¼‰ä¸¤ç§ï¼›
* è¾“å…¥æºï¼ˆInput Sourcesï¼‰åˆåˆ†ä¸º `Source0` å’Œ `Source1` ä¸¤ç§ï¼Œä»¥ä¸‹`__CFRunLoopSource` ä¸­çš„å…±ç”¨ä½“ `union` ä¸­çš„ `version0` å’Œ `version1` å°±åˆ†åˆ«å¯¹åº”Source0å’ŒSource1ã€‚

æ•°æ®ç»“æ„ï¼š
```
// CFRunLoopSourceRef æ˜¯ç»“æ„ä½“æŒ‡é’ˆ
typedef struct __CFRunLoopSource * CFRunLoopSourceRef;

struct __CFRunLoopSource {
    CFRuntimeBase _base;
    uint32_t _bits;
    pthread_mutex_t _lock;
    CFIndex _order;			/* immutable */
    CFMutableBagRef _runLoops;
    union {
        CFRunLoopSourceContext version0;	/* immutable, except invalidation */
        CFRunLoopSourceContext1 version1;	/* immutable, except invalidation */
    } _context;
};
```

`CFRunLoopSourceRef` æ˜¯äº‹ä»¶äº§ç”Ÿçš„åœ°æ–¹ã€‚Sourceæœ‰ä¸¤ä¸ªç‰ˆæœ¬ï¼š`Source0` å’Œ `Source1`ã€‚

|  è¾“å…¥æºï¼ˆInput Sourcesï¼‰   | åŒºåˆ«  | åº”ç”¨åœºæ™¯ |
|  ----  | ----  | ----  |
| Source0  | éç³»ç»Ÿå†…æ ¸äº‹ä»¶ï¼Œä¸å…·å¤‡ä¸»åŠ¨å”¤é†’çº¿ç¨‹çš„èƒ½åŠ›ï¼Œéœ€è¦æ‰‹åŠ¨å”¤é†’ã€‚å®ƒåªåŒ…å«äº†ä¸€ä¸ªå›è°ƒï¼ˆå‡½æ•°æŒ‡é’ˆï¼‰ï¼Œæ·»åŠ  `Source0` åˆ° `RunLoop` å¹¶ä¸ä¼šä¸»åŠ¨å”¤é†’çº¿ç¨‹ï¼Œéœ€è¦æ‰‹åŠ¨å”¤é†’ï¼šå…ˆè°ƒç”¨ `CFRunLoopSourceSignal(source)`ï¼Œå°†è¿™ä¸ª `Source` æ ‡è®°ä¸ºå¾…å¤„ç†ï¼Œç„¶åæ‰‹åŠ¨è°ƒç”¨ `CFRunLoopWakeUp(runloop)` æ¥å”¤é†’ `RunLoop`ï¼Œè®©å…¶å¤„ç†è¿™ä¸ªäº‹ä»¶ã€‚ | è§¦æ‘¸äº‹ä»¶ã€å“åº”äº‹ä»¶ï¼ˆ`performSelector:onThread:`ï¼‰ | 
| Source1  | ç³»ç»Ÿå†…æ ¸äº‹ä»¶ï¼Œå…·å¤‡å”¤é†’çº¿ç¨‹çš„èƒ½åŠ›ã€‚åŒ…å«äº†ä¸€ä¸ª `mach_port` å’Œä¸€ä¸ªå›è°ƒï¼ˆå‡½æ•°æŒ‡é’ˆï¼‰ï¼Œè¢«ç”¨äºé€šè¿‡å†…æ ¸å’Œå…¶ä»–çº¿ç¨‹ç›¸äº’å‘é€æ¶ˆæ¯ã€‚ | åŸºäº Port çš„çº¿ç¨‹é—´é€šä¿¡ã€ç³»ç»Ÿäº‹ä»¶æ•æ‰ï¼šç³»ç»Ÿäº‹ä»¶æ•æ‰æ˜¯ç”±Source1æ¥å¤„ç†ï¼Œç„¶åå†äº¤ç»™Source0å¤„ç† |

å…·ä½“å®ç°ä¼šåœ¨ä¸‹é¢ğŸ‘‡è®²åˆ°ã€‚


#### 4ã€`CFRunLoopTimerRef`

`CFRunLoopTimerRef` æ˜¯åŸºäºæ—¶é—´çš„è§¦å‘å™¨ï¼Œå®ƒå’Œ `NSTimer` æ˜¯ `toll-free bridged` çš„ï¼Œå¯ä»¥æ··ç”¨ã€‚å…¶åŒ…å«ä¸€ä¸ªæ—¶é—´é•¿åº¦å’Œä¸€ä¸ªå›è°ƒï¼ˆå‡½æ•°æŒ‡é’ˆï¼‰ã€‚å½“å…¶åŠ å…¥åˆ° RunLoop æ—¶ï¼ŒRunLoopä¼šæ³¨å†Œå¯¹åº”çš„æ—¶é—´ç‚¹ï¼Œå½“æ—¶é—´ç‚¹åˆ°æ—¶ï¼ŒRunLoopä¼šè¢«å”¤é†’ä»¥æ‰§è¡Œé‚£ä¸ªå›è°ƒã€‚

ä½œç”¨ï¼š
* `CFRunloopTimer` å’Œ `NSTimer` æ˜¯ toll-free bridged çš„ï¼Œå¯ä»¥ç›¸äº’è½¬æ¢ï¼›
* `performSelector:withObject:afterDelay:` æ–¹æ³•ä¼šåˆ›å»º timer å¹¶æ·»åŠ åˆ° RunLoop ä¸­ã€‚

æ•°æ®ç»“æ„ï¼š
```
// ç»“æ„ä½“æŒ‡é’ˆã€‚NSTimeråº•å±‚å°±æ˜¯åŸºäº CFRunLoopTimerRef å®ç°çš„
typedef struct CF_BRIDGED_MUTABLE_TYPE(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef;

struct __CFRunLoopTimer {
    CFRuntimeBase _base;
    uint16_t _bits;
    pthread_mutex_t _lock;
    CFRunLoopRef _runLoop;          // æ·»åŠ è¯¥ timer çš„ RunLoop
    CFMutableSetRef _rlModes;       // æ‰€æœ‰åŒ…å«è¯¥ timer çš„ modeName
    CFAbsoluteTime _nextFireDate;
    CFTimeInterval _interval;		/* immutable ç†æƒ³æ—¶é—´é—´éš” */
    CFTimeInterval _tolerance;          /* mutable æ—¶é—´åå·® */
    uint64_t _fireTSR;			/* TSR units */
    CFIndex _order;			/* immutable */
    CFRunLoopTimerCallBack _callout;	/* immutable å›è°ƒå…¥å£ */
    CFRunLoopTimerContext _context;	/* immutable, except invalidation */
};
```


#### 5ã€`CFRunLoopObserverRef`

`CFRunLoopObserverRef` æ˜¯RunLoopçš„è§‚å¯Ÿè€…ï¼Œæ¯ä¸ª `Observer` éƒ½åŒ…å«äº†ä¸€ä¸ªå›è°ƒï¼ˆå‡½æ•°æŒ‡é’ˆï¼‰ï¼Œå½“ RunLoop çš„çŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè§‚å¯Ÿè€…å°±èƒ½é€šè¿‡å›è°ƒæ¥å—åˆ°è¿™ä¸ªå˜åŒ–ã€‚å¯ä»¥è§‚æµ‹çš„ RunLoop çš„çŠ¶æ€æœ‰ä»¥ä¸‹å‡ ä¸ªï¼š

```
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL << 0), // å³å°†è¿›å…¥Loop
    kCFRunLoopBeforeTimers  = (1UL << 1), // å³å°†å¤„ç† Timer
    kCFRunLoopBeforeSources = (1UL << 2), // å³å°†å¤„ç† Source
    kCFRunLoopBeforeWaiting = (1UL << 5), // å³å°†è¿›å…¥ä¼‘çœ 
    kCFRunLoopAfterWaiting  = (1UL << 6), // åˆšä»ä¼‘çœ ä¸­å”¤é†’
    kCFRunLoopExit          = (1UL << 7), // é€€å‡ºLoop
};
```

Observer ç›‘å¬ RunLoop ç›‘å¬ 6 ç§çŠ¶æ€çš„ä½œç”¨ï¼š
* BeforeWaiting â€”â€” UI åˆ·æ–°
* BeforeWaiting â€”â€” Autorelease pool

æ•°æ®ç»“æ„ï¼š
```
// ç»“æ„ä½“æŒ‡é’ˆ
typedef struct __CFRunLoopObserver * CFRunLoopObserverRef;

struct __CFRunLoopObserver {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;
    CFRunLoopRef _runLoop;
    CFIndex _rlCount;
    CFOptionFlags _activities;		/* immutable ç›‘å¬çš„æ´»åŠ¨çŠ¶æ€ */
    CFIndex _order;			/* immutable */
    CFRunLoopObserverCallBack _callout;	/* immutable å›è°ƒå‡½æ•°ï¼Œå½“ RunLoopçŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä¼šå›è°ƒç»™è¯¥å‡½æ•° */
    CFRunLoopObserverContext _context;	/* immutable, except invalidation */
};
```

`CFRunLoopObserverRef` ä¸­çš„ `_activities` ç”¨æ¥ä¿å­˜ RunLoop çš„æ´»åŠ¨çŠ¶æ€ã€‚å½“ RunLoop çš„çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶ï¼Œé€šè¿‡å›è°ƒ `_callout` é€šçŸ¥æ‰€æœ‰ç›‘å¬è¿™ä¸ªçŠ¶æ€çš„ `Observer`ã€‚


`CFRunLoopSourceRef`ã€`CFRunLoopTimerRef` ã€`CFRunLoopObserverRef` è¢«ç»Ÿç§°ä¸º mode itemï¼Œä¸€ä¸ª item å¯ä»¥è¢«åŒæ—¶åŠ å…¥å¤šä¸ª modeã€‚ä½†ä¸€ä¸ª item è¢«é‡å¤åŠ å…¥åŒä¸€ä¸ª mode æ—¶æ˜¯ä¸ä¼šæœ‰æ•ˆæœçš„ã€‚å¦‚æœä¸€ä¸ª mode ä¸­ä¸€ä¸ª item éƒ½æ²¡æœ‰ï¼Œåˆ™ RunLoop ä¼šç›´æ¥é€€å‡ºï¼Œä¸è¿›å…¥å¾ªç¯ã€‚


## ä¸‰ã€`RunLoop` çš„äº‹ä»¶å¾ªç¯æœºåˆ¶

ä¸»çº¿ç¨‹ `RunLoop` çš„å¯åŠ¨è¿‡ç¨‹

é¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ä¸»çº¿ç¨‹çš„RunLoopçš„å¯åŠ¨è¿‡ç¨‹ã€‚`UIApplicationMain` å‡½æ•°å†…éƒ¨ä¼šå¯åŠ¨ä¸»çº¿ç¨‹çš„RunLoopã€‚
æ‰“æ–­ç‚¹ï¼Œé€šè¿‡ LLDB æŒ‡ä»¤ `bt` æŸ¥çœ‹å‡½æ•°è°ƒç”¨æ ˆå¦‚ä¸‹ï¼š

![æˆªå›¾](https://github.com/xiu619544553/dailyCode/blob/master/icons/runloopå¯åŠ¨.png)

å¯ä»¥çœ‹çº¢è‰²æ–¹æ¡†ä¸­ï¼Œ`UIApplicationMain` å‡½æ•°è°ƒç”¨äº† CoreFoundation æ¡†æ¶ä¸­çš„ `CFRunLoopRunSpecific` å‡½æ•°ã€‚

#### 1ã€`CFRunLoopRunSpecific` å‡½æ•°ï¼ŒRunLoop çš„å…¥å£

[ä¸‹è½½æºç ](http://opensource.apple.com/tarballs/CF/)ï¼ŒæŸ¥çœ‹æ–‡ä»¶ `CFRunLoop.c`ï¼Œå‡½æ•°æºç å¦‚ä¸‹ï¼š

```
/// RunLoopå…¥å£å‡½æ•°
/// @param rl RunLoop
/// @param modeName æ¨¡å¼åç§°
/// @param seconds loop è¶…æ—¶æ—¶é—´
/// @param returnAfterSourceHandled true:RunLoop å¤„ç†å®Œäº‹ä»¶å°±é€€å‡ºã€‚false:ä¸€ç›´è¿è¡Œç›´åˆ°è¶…æ—¶æˆ–è€…è¢«æ‰‹åŠ¨ç»ˆæ­¢
SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */
    
    CHECK_FOR_FORK();
    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;
    
    __CFRunLoopLock(rl);
    
    // æ ¹æ® modeName æ‰¾åˆ°æœ¬æ¬¡è¿è¡Œçš„ mode
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);
    
    // å¦‚æœæ²¡æ‰¾åˆ° || mode ä¸­æ²¡æœ‰æ³¨å†Œä»»ä½•äº‹ä»¶ï¼Œåˆ™å°±æ­¤åœæ­¢ï¼Œä¸è¿›å…¥å¾ªç¯
    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl->_currentMode)) {
        Boolean did = false;
        if (currentMode) __CFRunLoopModeUnlock(currentMode);
        __CFRunLoopUnlock(rl);
        return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;
    }
    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);
    CFRunLoopModeRef previousMode = rl->_currentMode;
    rl->_currentMode = currentMode;
    int32_t result = kCFRunLoopRunFinished;
    
    // é€šçŸ¥ Observersï¼šå³å°†è¿›å…¥ RunLoop
    if (currentMode->_observerMask & kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
    
    // RunLoop å…·ä½“è¦åšçš„äº‹æƒ…
    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
    
    // é€šçŸ¥ Observersï¼šå³å°†é€€å‡º RunLoop
    if (currentMode->_observerMask & kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
    
    __CFRunLoopModeUnlock(currentMode);
    __CFRunLoopPopPerRunData(rl, previousPerRun);
    rl->_currentMode = previousMode;
    __CFRunLoopUnlock(rl);
    return result;
}
```

æˆ‘ä»¬ä» CoreFoundation æºç ä¸­æ‰¾åˆ° CFRunLoopRunSpecific æ–¹æ³•ï¼Œç”±äºä»£ç è¿‡äºæŠ½è±¡ï¼Œæˆ‘ä»¬ä»æºç å‰¥ç¦»å‡ºæ¥å…³é”®ä»£ç ï¼š
```
SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */

    // é€šçŸ¥ Observersï¼šå³å°†è¿›å…¥ RunLoop
    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
    
    // RunLoop å…·ä½“è¦åšçš„äº‹æƒ…
	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
	
    // é€šçŸ¥ Observersï¼šå³å°†é€€å‡º RunLoop
    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);

    return result;
}
```

ä»å‡½æ•°è°ƒç”¨æ ˆï¼Œä»¥åŠ `CFRunLoopRunSpecific` å‡½æ•°çš„å®ç°ä¸­å¯ä»¥å¾—çŸ¥ï¼Œ`RunLoop` äº‹ä»¶å¾ªç¯çš„å®ç°æœºåˆ¶ä½“ç°åœ¨ `__CFRunLoopRun` å‡½æ•°ä¸­ã€‚

#### 2ã€`__CFRunLoopRun` å‡½æ•°å®ç°ï¼šäº‹ä»¶å¾ªç¯çš„å®ç°æœºåˆ¶

RunLoop å†…éƒ¨å®ç°é€»è¾‘å¦‚ä¸‹ï¼š

![RunLoopå†…éƒ¨é€»è¾‘](https://github.com/xiu619544553/dailyCode/blob/master/icons/runloopå†…éƒ¨é€»è¾‘.png)

æˆ‘ä»¬ä»ä¸Šé¢ä»£ç å¯ä»¥çŸ¥é“ï¼ŒRunLoop å…·ä½“å¤„ç†äº‹æƒ…çš„æ–¹æ³•æ˜¯ `__CFRunLoopRun`ï¼Œæˆ‘ä»¬ä»æºç å‰¥ç¦»å‡ºæ¥å…³é”®ä»£ç ï¼ˆå‰¥ç¦»å‡ºæ¥å…³é”®ä»£ç æˆ‘è§‰å¾—æ˜¯ä¸€ä¸ªåŠ æ·±ç†è§£çš„æ–¹å¼ï¼Œå‰¥ç¦»å®Œä¹‹ååœ¨å›å¤´çœ‹ RunLoop è¿è¡Œé€»è¾‘å›¾ï¼Œä¼šéå¸¸æ¸…æ™°ã€‚å¤§å®¶å¯ä»¥è‡ªå·±ä¸‹è½½æºç ï¼Œå»å°è¯•ä¸€éï¼‰ï¼š

```
/// äº‹ä»¶å¾ªç¯çš„å®ç°æœºåˆ¶
/// @param rl              è¿è¡Œçš„ RunLoop å¯¹è±¡
/// @param rlm             è¿è¡Œçš„ mode
/// @param seconds         loop è¶…æ—¶æ—¶é—´
/// @param stopAfterHandle true: RunLoop å¤„ç†å®Œäº‹ä»¶å°±é€€å‡º  false:ä¸€ç›´è¿è¡Œç›´åˆ°è¶…æ—¶æˆ–è€…è¢«æ‰‹åŠ¨ç»ˆæ­¢
/// @param previousMode    ä¸Šä¸€æ¬¡è¿è¡Œçš„ mode
/// @return                è¿”å› 4 ç§çŠ¶æ€
static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {
    int32_t retVal = 0;
    do {
        __CFRunLoopUnsetIgnoreWakeUps(rl);
        // é€šçŸ¥æ‰€æœ‰çš„ Observerï¼Œå³å°†å¤„ç† Timers
        if (rlm->_observerMask & kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);
        // é€šçŸ¥æ‰€æœ‰çš„ Observerï¼Œå³å°†å¤„ç† Sources
        if (rlm->_observerMask & kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);
        // å¤„ç† Blocks
	    __CFRunLoopDoBlocks(rl, rlm);
        // å¤„ç† Sources0
        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);
        if (sourceHandledThisLoop) {
            // å¤„ç† Blocks
            __CFRunLoopDoBlocks(rl, rlm);
        }
        
        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context->termTSR);
        if (MACH_PORT_NULL != dispatchPort && !didDispatchPortLastTime) {
            msg = (mach_msg_header_t *)msg_buffer;
            // åˆ¤æ–­æœ‰æ—  Sources1 å‰é¢æˆ‘ä»¬ä¹Ÿè®²äº† Sources1 è·Ÿç«¯å£ç›¸å…³
            if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {
            // å¦‚æœæœ‰ Sources1ï¼Œå°±è·³è½¬
                goto handle_msg;
            }
        }
        didDispatchPortLastTime = false;
        // é€šçŸ¥æ‰€æœ‰çš„ Observerï¼Œå³å°†ä¼‘çœ 
        if (!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);
        // å¼€å§‹ä¼‘çœ 
        __CFRunLoopSetSleeping(rl);
        do {
             // ç­‰å¾…åˆ«çš„æ¶ˆæ¯å”¤é†’åˆ«çš„çº¿ç¨‹ï¼Œå¦‚æœæ²¡å”¤é†’ä¼šä¸€ç›´å µå¡åœ¨è¿™é‡Œï¼Œå¦‚æœå”¤é†’å°±å¾€ä¸‹èµ°
            // CPU ä¸ä¼šç»™ä¼‘çœ çº¿ç¨‹åˆ†é…èµ„æºï¼Œé˜»å¡åœ¨è¿™é‡Œï¼Œå°±ä¸ä¼šç»§ç»­å¾€ä¸‹èµ°äº†
            // __CFRunLoopServiceMachPort é‡Œçš„ mach_msg æ˜¯å†…æ ¸å±‚é¢çš„ APIï¼Œæ²¡æœ‰æ¶ˆæ¯å°±è®©çº¿ç¨‹ä¼‘çœ ï¼Œæœ‰æ¶ˆæ¯å°±å”¤é†’çº¿ç¨‹ï¼Œè¿™é‡Œçš„ä¼‘çœ æ˜¯å®Œå…¨ä¸åšäº‹æƒ…ï¼Œä¸€è¡Œæ±‡ç¼–éƒ½ä¸ä¼šæ‰§è¡Œ
            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);
        } while (1);
        // åœæ­¢ä¼‘çœ 
        __CFRunLoopUnsetSleeping(rl);
        // é€šçŸ¥æ‰€æœ‰çš„ Observerï¼Œç»“æŸä¼‘çœ 
        if (!poll && (rlm->_observerMask & kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);
        
        handle_msg:
            // è¢« Timer å”¤é†’
            if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {
                CFRUNLOOP_WAKEUP_FOR_TIMER();
                // å¤„ç† Timer
                if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {
                    __CFArmNextTimerInMode(rlm, rl);
                }
            }
            // åŒä¸Š
            else if (rlm->_timerPort != MACH_PORT_NULL && livePort == rlm->_timerPort) {
                CFRUNLOOP_WAKEUP_FOR_TIMER();
                if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {
                    __CFArmNextTimerInMode(rlm, rl);
                }
            }
            // è¢« GCD å”¤é†’
            else if (livePort == dispatchPort) {
                // å¤„ç† GCD ç›¸å…³çš„äº‹æƒ…
                // GCD æœ‰è‡ªå·±çš„å¤„ç†é€»è¾‘ï¼Œå¾ˆå¤šä¸œè¥¿æ˜¯ä¸ä¾èµ– RunLoopï¼Œåªæœ‰ä»å­çº¿ç¨‹å›åˆ°ä¸»çº¿ç¨‹ä¼šä½¿ç”¨ï¼Œæ¯”å¦‚å­çº¿ç¨‹äº‹æƒ…åšå®Œå›åˆ°ä¸»çº¿ç¨‹åˆ·æ–° UIã€‚
                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
            } else { // è¢« Source1 å”¤é†’
                // å¤„ç† Source1 
                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;
                if (NULL != reply) {
                    (void)mach_msg(reply, MACH_SEND_MSG, reply->msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);
                }
            }
            // å¤„ç† Blocks
            __CFRunLoopDoBlocks(rl, rlm);
        // è®¾ç½®è¿”å›å€¼
        if (sourceHandledThisLoop && stopAfterHandle) {
            retVal = kCFRunLoopRunHandledSource;
            } else if (timeout_context->termTSR < mach_absolute_time()) {
                retVal = kCFRunLoopRunTimedOut;
        } else if (__CFRunLoopIsStopped(rl)) { // åœæ­¢ RunLoopï¼Œé€€å‡º while
                __CFRunLoopUnsetStopped(rl);
            retVal = kCFRunLoopRunStopped;
        } else if (rlm->_stopped) {  // åœæ­¢ RunLoopï¼Œé€€å‡º while
            rlm->_stopped = false;
            retVal = kCFRunLoopRunStopped;
        } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {
            retVal = kCFRunLoopRunFinished;
        }  
    } while (0 == retVal);
    return retVal;
}
```

#### 3ã€`__CFRunLoopServiceMachPort` å‡½æ•°å®ç°ï¼šRunLoop ä¼‘çœ çš„å®ç°åŸç†

åœ¨__CFRunLoopRunå‡½æ•°ä¸­ï¼Œä¼šè°ƒç”¨__CFRunLoopServiceMachPortå‡½æ•°ï¼Œè¯¥å‡½æ•°ä¸­è°ƒç”¨äº†mach_msg()å‡½æ•°æ¥è½¬ç§»å½“å‰çº¿ç¨‹çš„æ§åˆ¶æƒç»™å†…æ ¸æ€/ç”¨æˆ·æ€ã€‚
* æ²¡æœ‰æ¶ˆæ¯éœ€è¦å¤„ç†æ—¶ï¼Œä¼‘çœ çº¿ç¨‹ä»¥é¿å…èµ„æºå ç”¨ã€‚è°ƒç”¨mach_msg()ä»ç”¨æˆ·æ€åˆ‡æ¢åˆ°å†…æ ¸æ€ï¼Œç­‰å¾…æ¶ˆæ¯ï¼›
* æœ‰æ¶ˆæ¯éœ€è¦å¤„ç†æ—¶ï¼Œç«‹åˆ»å”¤é†’çº¿ç¨‹ï¼Œè°ƒç”¨mach_msg()å›åˆ°ç”¨æˆ·æ€å¤„ç†æ¶ˆæ¯ã€‚

è¿™å°±æ˜¯RunLoopä¼‘çœ çš„å®ç°åŸç†ï¼Œä¹Ÿæ˜¯RunLoopä¸ç®€å•çš„do...whileå¾ªç¯åŒºåˆ«ï¼š
* RunLoopï¼šä¼‘çœ çš„æ—¶å€™ï¼Œå½“å‰çº¿ç¨‹ä¸ä¼šåšä»»ä½•äº‹ï¼ŒCPU ä¸ä¼šå†åˆ†é…èµ„æºï¼›
* ç®€å•çš„do...whileå¾ªç¯ï¼šå½“å‰çº¿ç¨‹å¹¶æ²¡æœ‰ä¼‘æ¯ï¼Œä¸€ç›´å ç”¨ CPU èµ„æºã€‚

### å››ã€`RunLoop` çš„åº”ç”¨

#### 1ã€å¤„ç† `NSTimer` åœ¨ `UIScrollView` æ»‘åŠ¨æ—¶å¤±æ•ˆçš„é—®é¢˜

æˆ‘ä»¬çŸ¥é“ï¼Œ`RunLoop` åŒä¸€æ—¶é—´åªèƒ½è¿è¡Œåœ¨ä¸€ç§æ¨¡å¼ä¸‹ï¼Œå½“æˆ‘ä»¬æ»‘åŠ¨ `UIScrollView` åŠå…¶å­ç±»çš„æ—¶å€™ `RunLoop` ä¼šåˆ‡æ¢åˆ° `UITrackingRunLoopMode` ç•Œé¢è¿½è¸ªæ¨¡å¼ä¸‹ã€‚å¦‚æœæˆ‘ä»¬çš„ `NSTimer` æ˜¯æ·»åŠ åˆ° `RunLoop` çš„ `KCFRunLoopDefaultMode/NSDefaultRunLoopMode` é»˜è®¤æ¨¡å¼ä¸‹çš„è¯ï¼Œæ­¤æ—¶æ˜¯ä¼šå¤±æ•ˆçš„ã€‚

å¦‚æœæˆ‘ä»¬é€šè¿‡ä»¥ä¸‹æ–¹å¼åˆ›å»ºçš„ `NSTimer`ï¼Œtimer æ˜¯è‡ªåŠ¨æ·»åŠ åˆ° RunLoop çš„ Default æ¨¡å¼ä¸‹çš„
```
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block
```

å°† timeræ·»åŠ åˆ° CommonModes æ¨¡å¼ä¸‹ï¼Œèƒ½è§£å†³å¤±æ•ˆçš„é—®é¢˜ï¼š
```
// åˆ—è¡¨æ»‘åŠ¨æ—¶ï¼Œè®¡æ—¶å™¨æ­£å¸¸è®¡æ—¶
NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
    NSLog(@"xxx");
}];
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
```

æˆ‘ä»¬ä¸€èµ·æ¢è®¨ `CFRunLoopAddTimer` å‡½æ•°å®ç°ï¼š`CFRunLoopAddTimer()`å‡½æ•°ä¸­ä¼šåˆ¤æ–­ä¼ å…¥çš„modeNameæ¨¡å¼åç§°æ˜¯ä¸æ˜¯ `kCFRunLoopCommonModes` é€šç”¨æ¨¡å¼ï¼Œæ˜¯çš„è¯å°±ä¼šå°†timeræ·»åŠ åˆ°`RunLoop` çš„ `_commonModeItems` é›†åˆä¸­ï¼Œå¹¶åŒæ­¥è¯¥timeråˆ° `_commonModes` é‡Œçš„æ‰€æœ‰æ¨¡å¼ä¸­ï¼Œè¿™æ ·æ— è®ºåœ¨é»˜è®¤æ¨¡å¼è¿˜æ˜¯ç•Œé¢è¿½è¸ªæ¨¡å¼ä¸‹NSTimeréƒ½å¯ä»¥æ‰§è¡Œã€‚

æºç ï¼š
```
/// æ·»åŠ è®¡æ—¶å™¨
/// @param rl runloopå®ä¾‹
/// @param rlt timerå®ä¾‹
/// @param modeName runloopçš„æ¨¡å¼
void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) {    
    CHECK_FOR_FORK();
    if (__CFRunLoopIsDeallocating(rl)) return;
    if (!__CFIsValid(rlt) || (NULL != rlt->_runLoop && rlt->_runLoop != rl)) return;
    
    __CFRunLoopLock(rl);
    if (modeName == kCFRunLoopCommonModes) {      // å¦‚æœæ˜¯ CommonModes
        
        CFSetRef set = rl->_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl->_commonModes) : NULL;
        if (NULL == rl->_commonModeItems) {       // æ‡’åŠ è½½ï¼Œåˆ¤æ–­ _commonModeItems æ˜¯å¦ä¸ºç©ºï¼Œæ˜¯çš„è¯åˆ›å»º
            rl->_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
        }
        
        CFSetAddValue(rl->_commonModeItems, rlt); // å°† timer æ·»åŠ åˆ° _commonModeItems ä¸­
        
        if (NULL != set) {
            CFTypeRef context[2] = {rl, rlt};     // å°† timer å’Œ RunLoop å°è£…åˆ° context ä¸­
            /* add new item to all common-modes */
            
            // éå† commonModesï¼Œå°†è¢«æ ‡è®°ä¸ºCommonModesçš„ timer æ·»åŠ åˆ° commonModes çš„æ‰€æœ‰æ¨¡å¼ä¸‹
            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);
            CFRelease(set);
        }
        
    } else {
        .....
    }
    __CFRunLoopUnlock(rl);
}

/// å°†Source/Timer/Observeræ·»åŠ åˆ° CommonModesItems ä¸­
static void __CFRunLoopAddItemToCommonModes(const void *value, void *ctx) {
    CFStringRef modeName = (CFStringRef)value;
    CFRunLoopRef rl = (CFRunLoopRef)(((CFTypeRef *)ctx)[0]);
    CFTypeRef item = (CFTypeRef)(((CFTypeRef *)ctx)[1]);
    if (CFGetTypeID(item) == CFRunLoopSourceGetTypeID()) {
        CFRunLoopAddSource(rl, (CFRunLoopSourceRef)item, modeName);
    } else if (CFGetTypeID(item) == CFRunLoopObserverGetTypeID()) {
        CFRunLoopAddObserver(rl, (CFRunLoopObserverRef)item, modeName);
    } else if (CFGetTypeID(item) == CFRunLoopTimerGetTypeID()) {
        CFRunLoopAddTimer(rl, (CFRunLoopTimerRef)item, modeName);
    }
}
```


#### 2ã€åˆ©ç”¨ `RunLoop` ç›‘æ§åº”ç”¨å¡é¡¿


### äº”ã€`RunLoop` ç›¸å…³çš„é—®é¢˜

#### 1ã€`NSTimer` å’Œ `CADisplayLink` è®¡æ—¶ä¸å‡†ç¡®ï¼ŒåŠå…¶è§£å†³åŠæ³•

-------------------------------------
å‚è€ƒæ–‡ç« ï¼š
[iOS åº•å±‚åŸç†ï½œRunLoop è¯¦è§£](https://www.cnblogs.com/qiuzhaohai/p/14676869.html)
[æ·±å…¥æµ…å‡º RunLoopï¼ˆä¸‰ï¼‰ï¼šäº‹ä»¶å¾ªç¯æœºåˆ¶](https://juejin.cn/post/6844904073938878477)